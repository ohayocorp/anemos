package core

import (
	"fmt"
	"path"
	"reflect"
	"slices"
	"sort"
	"strings"

	"github.com/ohayocorp/anemos/pkg/js"
)

// DocumentGroup is a named container for multiple [Document] instances.
type DocumentGroup struct {
	Name            string
	Documents       []*Document
	AdditionalFiles []*AdditionalFile

	component *Component
}

type AdditionalFile struct {
	Path    string
	Content string
}

// Creates a new [DocumentGroup] with given name.
func NewDocumentGroup(name string) *DocumentGroup {
	return &DocumentGroup{
		Name: name,
	}
}

// Creates a new [AdditionalFile] with given path and content.
func NewAdditionalFile(path, content string) *AdditionalFile {
	return &AdditionalFile{
		Path:    path,
		Content: content,
	}
}

// Adds the given document to this group and sets its Group field to this group.
func (group *DocumentGroup) AddDocument(document *Document) {
	group.Documents = append(group.Documents, document)
	document.Group = group
}

// Adds the given additional file to this group.
func (group *DocumentGroup) AddAdditionalFile(additionalFile *AdditionalFile) {
	group.AdditionalFiles = append(group.AdditionalFiles, additionalFile)
}

// Returns the component that created this document group. Component is set when the
// document group is added to the builder context.
func (group *DocumentGroup) GetComponent() *Component {
	return group.component
}

// Returns the first document that has the given path. Returns nil if no document is found.
func (group *DocumentGroup) GetDocument(path string) *Document {
	return group.GetDocumentFunc(func(document *Document) bool {
		return document.Path == path
	})
}

// Returns the first document that satisfies the given predicate. Returns nil if no document is found.
func (group *DocumentGroup) GetDocumentFunc(predicate func(*Document) bool) *Document {
	for _, document := range group.Documents {
		if predicate(document) {
			return document
		}
	}

	return nil
}

// Returns the documents in this group sorted by their file path.
func (group *DocumentGroup) SortedDocuments() []*Document {
	sorted := make([]*Document, len(group.Documents))
	copy(sorted, group.Documents)

	sort.Slice(sorted, func(i, j int) bool {
		return sorted[i].Path < sorted[j].Path
	})

	return sorted
}

// Removes the given document from this group and sets its Group field to nil.
func (group *DocumentGroup) RemoveDocument(document *Document) {
	group.Documents = slices.DeleteFunc(group.Documents, func(d *Document) bool {
		return d == document
	})
	document.Group = nil
}

// Removes the given additional file from this group.
func (group *DocumentGroup) RemoveAdditionalFile(additionalFile *AdditionalFile) {
	group.AdditionalFiles = slices.DeleteFunc(group.AdditionalFiles, func(f *AdditionalFile) bool {
		return f == additionalFile
	})
}

// Removes all documents and additional files from this group and adds them to the given group.
func (group *DocumentGroup) MoveTo(other *DocumentGroup) {
	for _, document := range group.Documents {
		other.AddDocument(document)
	}

	for _, additionalFile := range group.AdditionalFiles {
		other.AddAdditionalFile(additionalFile)
	}

	group.Documents = nil
	group.AdditionalFiles = nil
}

// Sets the namespace of documents that are namespaced (e.g. Pod, Job, ...) to the given namespace.
func (group *DocumentGroup) SetNamespaces(context *BuildContext, namespace string) {
	for _, document := range group.Documents {
		apiVersion := document.GetApiVersion()
		if apiVersion == nil {
			return
		}

		kind := document.GetKind()
		if kind == nil {
			return
		}

		if context.KubernetesResourceInfo.IsNamespaced(*apiVersion, *kind) {
			document.SetNamespace(namespace)
		}
	}
}

type compareFieldGetter = func(*Document) *string

var compareFieldGetters []compareFieldGetter = []func(*Document) *string{
	func(x *Document) *string { return x.GetApiVersion() },
	func(x *Document) *string { return x.GetKind() },
	func(x *Document) *string { return x.GetNamespace() },
	func(x *Document) *string { return x.GetName() },
}

// Fixes duplicate document file paths by adding an index suffix to the end the names. Sorts the documents
// by their apiVersion, kind, namespace, and name to ensure consistent naming.
// This is useful for documents that are generated by Helm charts.
func (group *DocumentGroup) FixNameClashes() {
	groups := map[string][]*Document{}

	for _, document := range group.Documents {
		groups[document.Path] = append(groups[document.Path], document)
	}

	for documentPath, documents := range groups {
		if len(documents) == 1 {
			continue
		}

		sort.SliceStable(documents, func(i, j int) bool {
			for _, getter := range compareFieldGetters {
				x := getter(documents[i])
				y := getter(documents[j])

				if x == nil && y == nil {
					continue
				}

				if x == nil && y != nil {
					return true
				}

				if x != nil && y == nil {
					return false
				}

				if *x == *y {
					continue
				}

				return *x < *y
			}

			return false
		})

		for index, document := range documents {
			if index == 0 {
				continue
			}

			extension := path.Ext(documentPath)
			fileName := path.Base(documentPath)
			fileName, _ = strings.CutSuffix(fileName, extension)

			document.Path = fmt.Sprintf("%s-%d%s", fileName, index, extension)
		}
	}
}

func registerDocumentGroup(jsRuntime *js.JsRuntime) {
	jsRuntime.Type(reflect.TypeFor[DocumentGroup]()).Fields(
		js.Field("Name"),
		js.Field("Documents"),
		js.Field("AdditionalFiles"),
	).Methods(
		js.Method("AddDocument"),
		js.Method("AddAdditionalFile"),
		js.Method("GetComponent"),
		js.Method("GetDocument"),
		js.Method("GetDocumentFunc").JsName("getDocument"),
		js.Method("SortedDocuments"),
		js.Method("MoveTo"),
		js.Method("RemoveDocument"),
		js.Method("RemoveAdditionalFile"),
		js.Method("SetNamespaces"),
		js.Method("FixNameClashes"),
	).Constructors(
		js.Constructor(reflect.ValueOf(NewDocumentGroup)),
	)

	jsRuntime.Type(reflect.TypeFor[AdditionalFile]()).Fields(
		js.Field("Path"),
		js.Field("Content"),
	).Constructors(
		js.Constructor(reflect.ValueOf(NewAdditionalFile)),
	)
}
