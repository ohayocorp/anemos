package main

import (
	"fmt"
	"path"
	"path/filepath"
	"sort"
	"strings"

	mapset "github.com/deckarep/golang-set/v2"
	"github.com/ohayocorp/anemos/pkg/core"
)

// writeGoContents generates a Go source file for a Kubernetes type.
// This includes the struct definition, constructors, and JS registration code.
func (typeInfo *typeInfo) writeGoContents() error {
	if !typeInfo.IsDocument {
		return nil
	}

	fileName := fmt.Sprintf("%s.go", strings.ToLower(typeInfo.Name))
	filePath := filepath.Join(outputDir, typeInfo.PackagePath, fileName)

	file, err := NewGeneratedFile(filePath)
	if err != nil {
		return fmt.Errorf("failed to create output file: %w", err)
	}
	defer file.Close()

	contents := getDocumentTypeContents(typeInfo)

	file.Write(contents)
	return nil
}

func getDocumentTypeContents(typeInfo *typeInfo) string {
	template := core.MultilineString(`
		// Code generated by types_generator.go; DO NOT EDIT.

		package {{ .PackageName }}

		import (
			"reflect"

			"github.com/grafana/sobek"
			"github.com/ohayocorp/anemos/pkg/core"
			"github.com/ohayocorp/anemos/pkg/js"
		)

		func New{{ .TypeName }}(jsRuntime *js.JsRuntime) *core.Document {
			document := core.NewDocument(jsRuntime)
			{{ .TypeMetaSetter }}
			return document
		}

		func New{{ .TypeName }}WithSpec(spec *sobek.Object) *core.Document {
			document := core.NewDocumentWithContent(spec)
			{{ .TypeMetaSetter }}
			return document
		}

		func Register{{ .TypeName }}(jsRuntime *js.JsRuntime) {
			jsRuntime.Constructor(reflect.ValueOf(New{{ .TypeName }})).JsNamespace("k8s.{{ .JsNamespace }}").JsName("{{ .TypeName }}")
			jsRuntime.Constructor(reflect.ValueOf(New{{ .TypeName }}WithSpec)).JsNamespace("k8s.{{ .JsNamespace }}").JsName("{{ .TypeName }}")
			{{ if .GenerateAliasOnRoot }}
			jsRuntime.Constructor(reflect.ValueOf(New{{ .TypeName }})).JsNamespace("k8s").JsName("{{ .TypeName }}")
			jsRuntime.Constructor(reflect.ValueOf(New{{ .TypeName }}WithSpec)).JsNamespace("k8s").JsName("{{ .TypeName }}")
			{{ end }}
		}
		`)

	return core.ParseTemplate(template, map[string]any{
		"PackageName":         typeInfo.PackageName,
		"Description":         getDescription(typeInfo.Schema.Description),
		"TypeName":            typeInfo.Name,
		"JsNamespace":         strings.ReplaceAll(typeInfo.PackagePath, "/", "."),
		"TypeMetaSetter":      typeInfo.getTypeMetaSetter(),
		"GenerateAliasOnRoot": typeInfo.GenerateAliasOnRoot,
	})
}

// generateJsRegistrations creates a single Go file that registers all Kubernetes types
// with the JavaScript runtime.
func generateJsRegistrations() error {
	registerFile, err := NewGeneratedFile(filepath.Join(outputDir, "js_registrations.go"))
	if err != nil {
		return fmt.Errorf("failed to create js_registrations file: %w", err)
	}
	defer registerFile.Close()

	registrationFuncs := make([]string, 0, len(typeMappings))
	imports := mapset.NewSet[string]()

	for _, identifier := range core.SortedKeys(typeMappings) {
		typeInfo := typeMappings[identifier]
		if typeInfo.IsExcluded {
			continue
		}

		if typeInfo.IsDocument {
			registration := fmt.Sprintf("%s.Register%s(jsRuntime)", typeInfo.PackageAlias, typeInfo.Name)
			importLine := fmt.Sprintf(`%s "%s"`, typeInfo.PackageAlias, path.Join(packageBase, typeInfo.PackagePath))

			registrationFuncs = append(registrationFuncs, registration)
			imports.Add(importLine)
		} else {
			registration := fmt.Sprintf(
				`jsRuntime.Constructor(reflect.ValueOf(NewObject)).JsNamespace("k8s.%s").JsName("%s")`,
				strings.ReplaceAll(typeInfo.PackagePath, "/", "."),
				typeInfo.Name)

			registrationFuncs = append(registrationFuncs, registration)
			imports.Add(`"reflect"`)
		}
	}

	importsSlice := imports.ToSlice()
	sort.Strings(importsSlice)

	jsRegistrations := core.ParseTemplate(`
		// Code generated by types_generator.go; DO NOT EDIT.

		package k8s

		import (
			"github.com/grafana/sobek"
			"github.com/ohayocorp/anemos/pkg/js"

			{{ .Imports }}
		)

		func NewObject(jsRuntime *js.JsRuntime) *sobek.Object {
			return jsRuntime.Runtime.NewObject()
		}

		func RegisterK8S(jsRuntime *js.JsRuntime) {
			{{ .RegistrationFuncs }}
		}
		`,
		map[string]any{
			"Imports":           core.IndentTab(strings.Join(importsSlice, "\n"), 1),
			"RegistrationFuncs": core.IndentTab(strings.Join(registrationFuncs, "\n"), 1),
		})

	registerFile.Write(jsRegistrations)

	return nil
}

// getTypeMetaSetter generates code to set apiVersion and kind fields for types
// that have x-kubernetes-group-version-kind extensions in their schema.
func (typeInfo *typeInfo) getTypeMetaSetter() string {
	version, kind := typeInfo.getVersionKind()
	if version == nil || kind == nil {
		return ""
	}

	setter := core.ParseTemplate(`
		document.Set("apiVersion", "{{ .Version }}")
		document.Set("kind", "{{ .Kind }}")
		`,
		map[string]any{
			"Version": version,
			"Kind":    kind,
		})

	return core.IndentTab(setter, 1)
}

// getVersionKind extracts the API version and kind from a type's OpenAPI schema extensions.
func (typeInfo *typeInfo) getVersionKind() (*string, *string) {
	gvkExtension := typeInfo.Schema.Extensions["x-kubernetes-group-version-kind"]
	if gvkExtension == nil {
		return nil, nil
	}

	var version, kind *string

	if gvk, ok := gvkExtension.(map[string]any); ok {
		version = core.Pointer(gvk["version"].(string))
		kind = core.Pointer(gvk["kind"].(string))
	} else if gvks, ok := gvkExtension.([]any); ok && len(gvks) > 0 {
		gvk := gvks[0].(map[string]any)

		version = core.Pointer(gvk["version"].(string))
		kind = core.Pointer(gvk["kind"].(string))
	}

	if version == nil || kind == nil {
		panic(fmt.Errorf("invalid x-kubernetes-group-version-kind extension format"))
	}

	return version, kind
}
