package main

import (
	"fmt"
	"path"
	"path/filepath"
	"sort"
	"strings"

	mapset "github.com/deckarep/golang-set/v2"
	"github.com/ohayocorp/anemos/pkg/core"
	"github.com/ohayocorp/anemos/pkg/util"
)

// writeGoContents generates a Go source file for a Kubernetes type.
// This includes the struct definition, constructors, and JS registration code.
func (typeInfo *typeInfo) writeGoContents() error {
	if !typeInfo.IsDocument {
		return nil
	}

	fileName := fmt.Sprintf("%s.go", strings.ToLower(typeInfo.Name))
	filePath := filepath.Join(outputDir, typeInfo.PackagePath, fileName)

	file, err := NewGeneratedFile(filePath)
	if err != nil {
		return fmt.Errorf("failed to create output file: %w", err)
	}
	defer file.Close()

	contents := getDocumentTypeContents(typeInfo)

	file.Write(contents)
	return nil
}

func getDocumentTypeContents(typeInfo *typeInfo) string {
	template := util.MultilineString(`
		// Code generated by types_generator.go; DO NOT EDIT.

		package {{ .PackageName }}

		import (
			"reflect"

			"github.com/grafana/sobek"
			"github.com/ohayocorp/anemos/pkg/core"
			"github.com/ohayocorp/anemos/pkg/js"
		)

		func New{{ .TypeName }}(jsRuntime *js.JsRuntime) *core.Document {
			document := core.NewDocument(jsRuntime)
			{{ .TypeMetaSetter }}
			return document
		}

		func New{{ .TypeName }}WithSpec(spec *sobek.Object) *core.Document {
			document := core.NewDocumentWithContent(spec)
			{{ .TypeMetaSetter }}
			return document
		}

		func Register{{ .TypeName }}(jsRuntime *js.JsRuntime) {
			jsRuntime.Constructor(reflect.ValueOf(New{{ .TypeName }})).JsModule("k8s/{{ .JsModule }}").JsName("{{ .TypeName }}")
			jsRuntime.Constructor(reflect.ValueOf(New{{ .TypeName }}WithSpec)).JsModule("k8s/{{ .JsModule }}").JsName("{{ .TypeName }}")
			{{ if .GenerateAliasOnRoot }}
			jsRuntime.Constructor(reflect.ValueOf(New{{ .TypeName }})).JsModule("k8s").JsName("{{ .TypeName }}")
			jsRuntime.Constructor(reflect.ValueOf(New{{ .TypeName }}WithSpec)).JsModule("k8s").JsName("{{ .TypeName }}")
			{{ end }}
		}
		`)

	return util.ParseTemplate(template, map[string]any{
		"PackageName":         typeInfo.PackageName,
		"Description":         getDescription(typeInfo.Schema.Description),
		"TypeName":            typeInfo.Name,
		"JsModule":            typeInfo.PackagePath,
		"TypeMetaSetter":      typeInfo.getTypeMetaSetter(),
		"GenerateAliasOnRoot": typeInfo.GenerateAliasOnRoot,
	})
}

// generateJsRegistrations creates a single Go file that registers all Kubernetes types
// with the JavaScript runtime.
func generateJsRegistrations() error {
	registerFile, err := NewGeneratedFile(filepath.Join(outputDir, "js_registrations.go"))
	if err != nil {
		return fmt.Errorf("failed to create js_registrations file: %w", err)
	}
	defer registerFile.Close()

	registrationFuncs := make([]string, 0, len(typeMappings))
	imports := mapset.NewSet[string]()

	for _, identifier := range core.SortedKeys(typeMappings) {
		typeInfo := typeMappings[identifier]
		if typeInfo.IsExcluded {
			continue
		}

		if typeInfo.IsDocument {
			registration := fmt.Sprintf("%s.Register%s(jsRuntime)", typeInfo.PackageAlias, typeInfo.Name)
			importLine := fmt.Sprintf(`%s "%s"`, typeInfo.PackageAlias, path.Join(packageBase, typeInfo.PackagePath))

			registrationFuncs = append(registrationFuncs, registration)
			imports.Add(importLine)
		} else {
			registration := fmt.Sprintf(
				`jsRuntime.Constructor(reflect.ValueOf(NewObject)).JsModule("k8s/%s").JsName("%s")`,
				typeInfo.PackagePath,
				typeInfo.Name)

			registrationFuncs = append(registrationFuncs, registration)
			imports.Add(`"reflect"`)
		}
	}

	importsSlice := imports.ToSlice()
	sort.Strings(importsSlice)

	jsRegistrations := util.ParseTemplate(`
		// Code generated by types_generator.go; DO NOT EDIT.

		package k8s

		import (
			"github.com/grafana/sobek"
			"github.com/ohayocorp/anemos/pkg/js"

			{{ .Imports }}
		)

		func NewObject(jsRuntime *js.JsRuntime) *sobek.Object {
			return jsRuntime.Runtime.NewObject()
		}

		func RegisterK8S(jsRuntime *js.JsRuntime) {
			{{ .RegistrationFuncs }}
		}
		`,
		map[string]any{
			"Imports":           util.IndentTab(strings.Join(importsSlice, "\n"), 1),
			"RegistrationFuncs": util.IndentTab(strings.Join(registrationFuncs, "\n"), 1),
		})

	registerFile.Write(jsRegistrations)

	return nil
}

// getTypeMetaSetter generates code to set apiVersion and kind fields for types
// that have x-kubernetes-group-version-kind extensions in their schema.
func (typeInfo *typeInfo) getTypeMetaSetter() string {
	group, version, kind := typeInfo.getGroupVersionKind()
	if version == nil || kind == nil {
		return ""
	}

	apiVersion := *version
	if group != nil && *group != "" {
		apiVersion = fmt.Sprintf("%s/%s", *group, *version)
	}

	setter := util.ParseTemplate(`
		document.Set("apiVersion", "{{ .ApiVersion }}")
		document.Set("kind", "{{ .Kind }}")
		`,
		map[string]any{
			"ApiVersion": apiVersion,
			"Kind":       kind,
		})

	return util.IndentTab(setter, 1)
}

// getGroupVersionKind extracts the API version and kind from a type's OpenAPI schema extensions.
func (typeInfo *typeInfo) getGroupVersionKind() (*string, *string, *string) {
	gvkExtension := typeInfo.Schema.Extensions["x-kubernetes-group-version-kind"]
	if gvkExtension == nil {
		return nil, nil, nil
	}

	var group, version, kind *string

	if gvk, ok := gvkExtension.(map[string]any); ok {
		group = core.Pointer(gvk["group"].(string))
		version = core.Pointer(gvk["version"].(string))
		kind = core.Pointer(gvk["kind"].(string))
	} else if gvks, ok := gvkExtension.([]any); ok && len(gvks) > 0 {
		gvk := gvks[0].(map[string]any)

		group = core.Pointer(gvk["group"].(string))
		version = core.Pointer(gvk["version"].(string))
		kind = core.Pointer(gvk["kind"].(string))
	}

	if version == nil || kind == nil {
		panic(fmt.Errorf("invalid x-kubernetes-group-version-kind extension format"))
	}

	return group, version, kind
}
